"""Generate the Glitchling Monster Manual from live glitchling metadata."""

from __future__ import annotations

import argparse
import inspect
import sys
import textwrap
from enum import Enum
from pathlib import Path
from typing import TYPE_CHECKING, Any, Iterable, Mapping, Sequence

if TYPE_CHECKING:
    from glitchlings.zoo import Glitchling as GlitchlingType
else:  # pragma: no cover - import guard for runtime
    GlitchlingType = Any

REPO_ROOT = Path(__file__).resolve().parents[1]
SRC_PATH = REPO_ROOT / "src"
DEFAULT_OUTPUT = REPO_ROOT / "docs" / "monster-manual.md"
LINE_WIDTH = 88


def _load_glitchlings() -> Mapping[str, GlitchlingType]:
    """Return the builtin glitchling registry with import guards applied."""
    if str(SRC_PATH) not in sys.path:
        sys.path.insert(0, str(SRC_PATH))

    from glitchlings.zoo import BUILTIN_GLITCHLINGS

    return BUILTIN_GLITCHLINGS


def _format_annotation(annotation: Any) -> str:
    """Return a concise string for a parameter annotation."""
    if annotation is inspect._empty:
        return "unspecified"
    if isinstance(annotation, str):
        return annotation
    origin = getattr(annotation, "__origin__", None)
    if origin is not None:
        return str(annotation).replace("typing.", "")
    if getattr(annotation, "__module__", "") == "builtins":
        return getattr(annotation, "__name__", str(annotation))
    return str(annotation).replace("typing.", "")


def _format_default(value: Any) -> str:
    """Return a human-friendly representation of a default parameter value."""
    if value is inspect._empty:
        return "required"
    if isinstance(value, str):
        return f'"{value}"'
    if isinstance(value, bool):
        return str(value).lower()
    if isinstance(value, Enum):
        label = getattr(value, "label", None)
        return str(label) if label is not None else value.name
    return repr(value)


def _resolve_flavor(glitchling: GlitchlingType) -> str | None:
    """Return flavour text from the glitchling or its configured evolution."""
    flavor_attr = getattr(glitchling, "flavor", None)
    if isinstance(flavor_attr, str) and flavor_attr.strip():
        return flavor_attr.strip()

    stone = getattr(glitchling, "kwargs", {}).get("stone")
    if stone is not None:
        try:
            from glitchlings.zoo.pedant.core import EVOLUTIONS

            form_cls = EVOLUTIONS.get(stone)
        except Exception:  # pragma: no cover - defensive import guard
            form_cls = None
        if form_cls is not None:
            pedant_flavor = getattr(form_cls, "flavor", None)
            if pedant_flavor:
                return str(pedant_flavor)

    return None


def _parameter_lines(glitchling: GlitchlingType) -> Iterable[str]:
    """Yield formatted parameter bullets for the glitchling's initializer."""
    signature = inspect.signature(type(glitchling).__init__)
    for name, parameter in signature.parameters.items():
        if name == "self":
            continue
        if parameter.kind in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD):
            continue
        default = getattr(glitchling, "kwargs", {}).get(name, parameter.default)
        annotation = _format_annotation(parameter.annotation)
        default_text = _format_default(default)
        yield f"- `{name}` ({annotation}): default {default_text}"


def _wrap(text: str) -> str:
    """Wrap text at the shared line width."""
    return textwrap.fill(text, width=LINE_WIDTH)


def build_monster_manual(glitchlings: Mapping[str, GlitchlingType] | None = None) -> str:
    """Construct the full Monster Manual markdown from live glitchlings."""
    if glitchlings is None:
        glitchlings = _load_glitchlings()

    header = (
        "# Glitchling Monster Manual\n\n"
        "This file is generated by `docs/build_monster_manual.py` so it always reflects the "
        "current glitchling defaults. Regenerate it after changing parameters or adding new "
        "glitchlings.\n"
    )

    sections: list[str] = [header]
    for glitchling in (glitchlings[name] for name in sorted(glitchlings)):
        sections.append(f"## {glitchling.name}\n")

        description = inspect.getdoc(type(glitchling)) or ""
        if description:
            sections.append(_wrap(description))
            sections.append("")

        flavor = _resolve_flavor(glitchling)
        if flavor:
            sections.append(f'*"{flavor}"*')
            sections.append("")

        sections.append(f"- **Scope:** {glitchling.level.name.title()}")
        sections.append(f"- **Order:** {glitchling.order.name.title()}")
        sections.append("")

        sections.append("### Parameters")
        sections.append("")
        params = list(_parameter_lines(glitchling))
        if params:
            sections.extend(params)
        else:
            sections.append("- None")
        sections.append("")

    return "\n".join(sections).rstrip() + "\n"


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    """Parse CLI arguments."""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--output",
        type=Path,
        default=DEFAULT_OUTPUT,
        help="Destination file for the generated manual. Defaults to docs/monster-manual.md.",
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str] | None = None) -> None:
    """Entry point for the Monster Manual generator."""
    args = parse_args(argv)
    output: Path = args.output
    if not output.is_absolute():
        output = REPO_ROOT / output

    content = build_monster_manual()
    output.write_text(content, encoding="utf-8")
    print(f"Wrote {output.relative_to(REPO_ROOT)}")


if __name__ == "__main__":
    main()
