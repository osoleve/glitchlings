# Glitchling Monster Manual

This file is generated by `docs/build_monster_manual.py` so it always reflects the current glitchling defaults. Regenerate it after changing parameters or adding new glitchlings.

---

!!! quote "üëÇ Ekkokin"

    === "Stats"

        | Attribute | Value |
        |-----------|-------|
        | **Class** | Homophone Specialist |
        | **Scope** | Word |
        | **Initiative** | Early |
        | **Signature** | Phonetic word substitution |

        **Parameters**

        | Parameter | Type | Default |
        |-----------|------|---------|
        | `rate` | float \| None | 0.02 |
        | `seed` | int \| None | None |

    === "Description"

        *"Homophonic idiolectician. There leased favourite flavour? Orange."*

        Ekkokin is a cunning glitchling that swaps words for their curated homophones‚Äîwords that sound identical but have different spellings and meanings. This creates text that reads correctly when spoken aloud but is subtly wrong on the page.

        Perfect for:

        - Testing spell-checker robustness
        - Creating "sounds right" adversarial examples
        - Simulating common ESL mistakes

    === "Example"

        **Input:**
        ```text
        The knight rode through the night to the castle.
        ```

        **Output:**
        ```text
        The night road through the knight to the castle.
        ```

---

!!! quote "ü¶í Hokey"

    === "Stats"

        | Attribute | Value |
        |-----------|-------|
        | **Class** | Character Stretcher |
        | **Scope** | Character |
        | **Initiative** | First |
        | **Signature** | Vowel/consonant elongation |

        **Parameters**

        | Parameter | Type | Default |
        |-----------|------|---------|
        | `rate` | float | 0.3 |
        | `extension_min` | int | 2 |
        | `extension_max` | int | 5 |
        | `word_length_threshold` | int | 6 |
        | `base_p` | float | 0.45 |
        | `seed` | int \| None | None |

    === "Description"

        *"Sooooo excited to meet you! We reeeeeally missed you last week."*

        Hokey is an enthusiastic glitchling that stretches words using sophisticated linguistic heuristics. It identifies stretchable phonemes within words and elongates them to create expressive, informal text patterns.

        The stretching algorithm considers:

        - Word length thresholds
        - Phoneme position within words
        - Linguistic rules for natural-sounding extensions

        Perfect for:

        - Simulating excited/casual online speech
        - Testing tokenizer handling of repeated characters
        - Creating expressive text variations

    === "Example"

        **Input:**
        ```text
        I found myself transformed in his bed.
        ```

        **Output:**
        ```text
        I foooooouuuuuund myself transformed in his bed.
        ```

---

!!! quote "üìá Jargoyle"

    === "Stats"

        | Attribute | Value |
        |-----------|-------|
        | **Class** | Lexical Shifter |
        | **Scope** | Word |
        | **Initiative** | Normal |
        | **Signature** | Dictionary-based word swaps |

        **Parameters**

        | Parameter | Type | Default |
        |-----------|------|---------|
        | `lexemes` | str | "synonyms" |
        | `mode` | JargoyleMode | "drift" |
        | `rate` | float \| None | 0.01 |
        | `seed` | int \| None | None |

    === "Description"

        *"Oh no... The worst person you know just bought a thesaurus..."*

        Jargoyle is a lexical shapeshifter that swaps words using bundled dictionaries. It supports multiple lexeme collections:

        - **colors**: Swap color terms (e.g., "red" ‚Üí "blue")
        - **synonyms**: General synonym substitution
        - **corporate**: Business jargon alternatives
        - **academic**: Scholarly word substitutions
        - **cyberpunk**: Neon cyberpunk slang
        - **lovecraftian**: Cosmic horror terminology
        - **custom**: Drop any `*.json` into `assets/lexemes/`

        Two modes available:

        - **literal**: Use the first canonical entry
        - **drift**: Randomly select from alternatives

    === "Example"

        **Input:**
        ```text
        The quick fox jumps fast over the lazy dog.
        ```

        **Output (synonyms, drift mode):**
        ```text
        The swift fox leaps rapid over the lazy dog.
        ```

---

!!! quote "üé≠ Mim1c"

    === "Stats"

        | Attribute | Value |
        |-----------|-------|
        | **Class** | Visual Deceiver |
        | **Scope** | Character |
        | **Initiative** | Last |
        | **Signature** | Homoglyph substitution |

        **Parameters**

        | Parameter | Type | Default |
        |-----------|------|---------|
        | `rate` | float \| None | 0.02 |
        | `classes` | list[str] \| Literal['all'] \| None | None |
        | `banned_characters` | Collection[str] \| None | None |
        | `seed` | int \| None | None |

    === "Description"

        *"Breaks your parser by replacing some characters in strings with doppelgangers. Don't worry, this text is clean. ;)"*

        Mim1c is a master of visual deception, swapping characters for homoglyphs‚Äîcharacters from different Unicode blocks that look nearly identical. The text appears unchanged to human readers but wreaks havoc on string comparisons and parsers.

        Homoglyph classes include:

        - Cyrillic lookalikes (–∞, –µ, –æ, —Ä, —Å, —Ö)
        - Mathematical symbols (‚ÑØ, ‚Ñ¥)
        - Fullwidth characters
        - Latin Extended forms

        Perfect for:

        - Testing Unicode normalization
        - Creating visually-identical adversarial text
        - Breaking naive string matching

    === "Example"

        **Input:**
        ```text
        Hello World
        ```

        **Output:**
        ```text
        Œóello WŒørld
        ```
        *(H‚ÜíŒó Greek, o‚ÜíŒø Greek)*

---

!!! quote "üìù Pedant"

    === "Stats"

        | Attribute | Value |
        |-----------|-------|
        | **Class** | Linguistic Archaeologist |
        | **Scope** | Word |
        | **Initiative** | Late |
        | **Signature** | Archaic evolution forms |

        **Parameters**

        | Parameter | Type | Default |
        |-----------|------|---------|
        | `stone` | PedantStone \| str | Coeurite |
        | `seed` | int \| None | None |

    === "Description"

        *"Resurrects archaic ligatures and diacritics."*

        Pedant is a scholarly glitchling that applies "evolution stones" to transform text into archaic or specialized forms. Each stone unlocks different linguistic transformations:

        - **Coeurite**: Old French heart-ligatures (≈ì, √¶)
        - **Umlaite**: Germanic diacritics
        - **Thornite**: Old English characters (√æ, √∞)

        Perfect for:

        - Testing legacy character handling
        - Creating period-appropriate text
        - Exercising Unicode edge cases

    === "Example"

        **Input:**
        ```text
        The aesthetic encyclopaedia
        ```

        **Output (Coeurite):**
        ```text
        The √¶sthetic encyclop√¶dia
        ```

---

!!! quote "üïµÔ∏è Redactyl"

    === "Stats"

        | Attribute | Value |
        |-----------|-------|
        | **Class** | Information Censor |
        | **Scope** | Word |
        | **Initiative** | Normal |
        | **Signature** | Block character redaction |

        **Parameters**

        | Parameter | Type | Default |
        |-----------|------|---------|
        | `replacement_char` | str | "‚ñà" |
        | `rate` | float \| None | 0.025 |
        | `merge_adjacent` | bool | false |
        | `seed` | int | 151 |
        | `unweighted` | bool | false |

    === "Description"

        *"Some things are better left ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà."*

        Redactyl is a censorious glitchling that redacts words with solid block characters. It simulates classified documents, FOIA releases, and censored communications.

        Features:

        - Configurable replacement character
        - Optional adjacent-word merging
        - Weighted or unweighted word selection

        Perfect for:

        - Creating redacted document simulations
        - Testing OCR on censored text
        - Training models on incomplete information

    === "Example"

        **Input:**
        ```text
        The secret meeting occurred at midnight.
        ```

        **Output:**
        ```text
        The ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà meeting occurred at ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà.
        ```

---

!!! quote "üí® Rushmore"

    === "Stats"

        | Attribute | Value |
        |-----------|-------|
        | **Class** | Chaos Agent |
        | **Scope** | Word |
        | **Initiative** | Normal |
        | **Signature** | Multi-mode word attacks |

        **Parameters**

        | Parameter | Type | Default |
        |-----------|------|---------|
        | `modes` | RushmoreMode \| str \| Iterable | (delete,) |
        | `rate` | float \| None | None |
        | `delete_rate` | float \| None | None |
        | `duplicate_rate` | float \| None | None |
        | `swap_rate` | float \| None | None |
        | `seed` | int \| None | None |
        | `unweighted` | bool | false |

    === "Description"

        *"You shouldn't have waited for the last minute to write that paper, anon. Sure hope everything is in the right place."*

        Rushmore is a versatile glitchling that bundles three distinct attack modes:

        - **delete**: Randomly removes words from text
        - **duplicate**: Repeats words in place
        - **swap**: Exchanges adjacent word positions

        Modes can be combined for compound chaos. Each mode has independent rate controls for fine-grained corruption.

        Perfect for:

        - Simulating hasty writing errors
        - Testing grammar correction models
        - Creating incomplete/jumbled text

    === "Example"

        **Input:**
        ```text
        He found himself transformed in his bed.
        ```

        **Output (delete mode):**
        ```text
        He found transformed his bed.
        ```

---

!!! quote "üîç Scannequin"

    === "Stats"

        | Attribute | Value |
        |-----------|-------|
        | **Class** | OCR Simulator |
        | **Scope** | Character |
        | **Initiative** | Late |
        | **Signature** | Scan artifact injection |

        **Parameters**

        | Parameter | Type | Default |
        |-----------|------|---------|
        | `rate` | float \| None | 0.02 |
        | `seed` | int \| None | None |

    === "Description"

        *"Isn't it weird how the word 'bed' looks like a bed?"*

        Scannequin simulates OCR (Optical Character Recognition) artifacts using common character confusions. It recreates the errors that occur when physical documents are scanned and digitized.

        Common confusions:

        - `rn` ‚Üî `m`
        - `cl` ‚Üî `d`
        - `l` ‚Üî `1` ‚Üî `I`
        - `O` ‚Üî `0`
        - `vv` ‚Üî `w`

        Perfect for:

        - Testing OCR post-processing
        - Creating realistic scan artifacts
        - Training OCR error correction models

    === "Example"

        **Input:**
        ```text
        The brown dog jumped over the wall.
        ```

        **Output:**
        ```text
        The brovvn clog jurnped over the waII.
        ```

---

!!! quote "‚å®Ô∏è Typogre"

    === "Stats"

        | Attribute | Value |
        |-----------|-------|
        | **Class** | Keyboard Gremlin |
        | **Scope** | Character |
        | **Initiative** | Early |
        | **Signature** | Adjacent-key typos |

        **Parameters**

        | Parameter | Type | Default |
        |-----------|------|---------|
        | `rate` | float \| None | 0.02 |
        | `keyboard` | str | "CURATOR_QWERTY" |
        | `seed` | int \| None | None |

    === "Description"

        *"What a nice word, would be a shame if something happened to it..."*

        Typogre is a mischievous glitchling that introduces keyboard-adjacent typing errors. It uses curated keyboard layout maps to inject realistic typos‚Äîthe kind humans make when their fingers slip to neighboring keys.

        Supported keyboards:

        - QWERTY (US, UK variants)
        - QWERTZ (German)
        - AZERTY (French)
        - Dvorak
        - Custom layouts via CURATOR format

        Perfect for:

        - Simulating human typing errors
        - Testing spell-check systems
        - Creating realistic noisy training data

    === "Example"

        **Input:**
        ```text
        The quick brown fox jumps.
        ```

        **Output:**
        ```text
        Thr quicl brown gox jumps.
        ```

---

!!! quote "‚õìÔ∏è‚Äçüí• Zeedub"

    === "Stats"

        | Attribute | Value |
        |-----------|-------|
        | **Class** | Invisible Saboteur |
        | **Scope** | Character |
        | **Initiative** | Last |
        | **Signature** | Zero-width character injection |

        **Parameters**

        | Parameter | Type | Default |
        |-----------|------|---------|
        | `rate` | float \| None | 0.02 |
        | `seed` | int \| None | None |
        | `characters` | Sequence[str] \| None | None |

    === "Description"

        *"I'm invoking my right to remain silent."*

        Zeedub is a stealthy glitchling that plants zero-width invisible characters inside words. The text looks completely normal but contains hidden Unicode ghosts that break string matching, tokenization, and search.

        Zero-width characters used:

        - `U+200B` Zero Width Space
        - `U+200C` Zero Width Non-Joiner
        - `U+200D` Zero Width Joiner
        - `U+FEFF` Zero Width No-Break Space

        Perfect for:

        - Testing Unicode handling
        - Creating "invisible" text corruption
        - Breaking naive string comparisons
        - Evading keyword filters

    === "Example"

        **Input:**
        ```text
        Hello World
        ```

        **Output:**
        ```text
        Hel‚Äãlo Wor‚Äãld
        ```
        *(Contains invisible U+200B between characters)*
